// I assume a batch size of 4 and a buffer size of 12 in the test
// refer to ringbuffer.h

suite(ringbuffer, { 
    unit("create buffer from file", {
	ringbuffer b;
	init_filebuffer(&b, "numbers.txt");

	printf("batch_size: %d, buffer_size: %d\n", BATCH_SIZE, BUFFER_SIZE);
	
	assert(b.type == FileBuffer);
	assert(b.name == "numbers.txt");
	assert(b.source.as_file.fileptr != NULL);
	assert(b.position == 0);
	assert(b.buffer_limit != 0);
	assert(b.line == 1);
	assert(b.column == 0);

	free_ringbuffer(&b);
    });
    
    unit("create stream from string", {
	ringbuffer b;
	init_stringbuffer(&b, "");

	assert(b.type == StringBuffer);
	// source should be NULL, since the buffer is not a file
	assert(b.position == 0);
	// last pos. should be 0, because the string is empty
	assert(b.buffer_limit == 0);

	free_ringbuffer(&b);
    });
    
    unit("get_character (from string)", {
	ringbuffer b;
	init_stringbuffer(&b, "abc");
	char x;

	get_character(&b, &x);
	assert(x == 'a');
	get_character(&b, &x);
	assert(x == 'b');
	get_character(&b, &x);
	assert(x == 'c');

	// we test twice, and completely disregard Humes advice
	get_character(&b, &x);
	assert(x == EOF);

	get_character(&b, &x);
	assert(x == EOF);

	free_ringbuffer(&b);
    });

    // if this suddenly broke, make sure the file is still the same :-)
    unit("get_character (from file)", {
	ringbuffer b;
	init_filebuffer(&b, "numbers.txt");
	char x;

	get_character(&b, &x);
	assert(x == '0');

	get_character(&b, &x);
	assert(x == ' ');

	get_character(&b, &x);
	assert(x == '1');

	free_ringbuffer(&b);
    });
    
    unit("empty buffer yields EOF forever (string)", {
	ringbuffer b;
	init_stringbuffer(&b, "");
	char x;

	for (int i = 0; i < 25; i++) {
	  get_character(&b, &x);
	  assert(x == EOF);
	}
	
	free_ringbuffer(&b);
    });

    unit("empty buffer yields EOF forever (file)", {
	ringbuffer b;
	init_filebuffer(&b, "empty.txt");
	char x;
	
	for (int i = 0; i < 25; i++) {
	  get_character(&b, &x);
	  assert(x == EOF);
	}
	
	free_ringbuffer(&b);
    });
    
    unit("lookahead (string)", {
	ringbuffer b;
	int error_code = 0;

	error_code = init_stringbuffer(&b, "abc");
	assert(!error_code);

	assert(look_ahead(&b, 0) == 'a');
	assert(look_ahead(&b, 1) == 'b');
	assert(look_ahead(&b, 2) == 'c');
	
	free_ringbuffer(&b);
    });

    unit("column and line tracking (string)", {
	ringbuffer b;
	int error_code = 0;
	error_code = init_stringbuffer(&b,
				       "abc\n"
				       "def\n"
				       "ghi\n");

	assert(!error_code);

	char x;
	for (int j = 1; j <= 3; j++) {
	  for (int i = 1; i <= 4; i++) {
	    get_character(&b, &x);
	    //printf("%zu, %zu. %d, %d\n", b.column, b.line, i, j);
	    assert(b.column == i);
	    assert(b.line == j);
	  }
	}

	// verify that we get EOF forever, and that the line/column
	// does not move past the first EOF
	for (int i = 0; i < 25; i++) {
	  get_character(&b, &x);
	  assert(x == EOF);
	  //printf("i: %d, line: %zu, col: %zu\n", i, b.line, b.column);
	  assert(b.line == 4);
	  assert(b.column == 1);
	}

	free_ringbuffer(&b);
    });

    unit("lookahead (file)", {
	ringbuffer b;
	int error_code = 0;
	char c;

	error_code = init_filebuffer(&b, "rbuf_lookahead_and_cursor");
	assert(!error_code);

	assert(look_ahead(&b, 0) == '1');
	assert(look_ahead(&b, 1) == '2');
	assert(look_ahead(&b, 2) == '3');
	assert(look_ahead(&b, 3) == '\n');

	error_code = get_character(&b, &c);
	assert(!error_code);
	assert(c == '1');

	assert(look_ahead(&b, 0) == '2');
	assert(look_ahead(&b, 1) == '3');
	assert(look_ahead(&b, 2) == '\n');
	assert(look_ahead(&b, 3) == 'a');

	error_code = get_character(&b, &c);
	assert(!error_code);
	assert(c == '2');

	assert(look_ahead(&b, 0) == '3');
	assert(look_ahead(&b, 1) == '\n');
	assert(look_ahead(&b, 2) == 'a');
	assert(look_ahead(&b, 3) == 'b');
	
	error_code = get_character(&b, &c);
	assert(!error_code);
	assert(c == '3');

	assert(look_ahead(&b, 0) == '\n');
	assert(look_ahead(&b, 1) == 'a');
	assert(look_ahead(&b, 2) == 'b');
	assert(look_ahead(&b, 3) == 'c');
	
	// here we expect the buffer to advance
	error_code = get_character(&b, &c);
	assert(!error_code);
	assert(c == '\n');

	assert(look_ahead(&b, 0) == 'a');
	assert(look_ahead(&b, 1) == 'b');
	assert(look_ahead(&b, 2) == 'c');
	assert(look_ahead(&b, 3) == '\n');
	
	free_ringbuffer(&b);
    });
    
    unit("column and line tracking (file)", {
	ringbuffer b;

	assert(false);
	
	free_ringbuffer(&b);
    });
    
})

/* Local Variables:  */
/* mode: c           */
/* End:              */
